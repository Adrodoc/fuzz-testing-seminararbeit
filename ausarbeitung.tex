\documentclass[a4paper,11pt]{article}

% Macht evtl unter Windows Probleme?
\usepackage[utf8]{inputenc}

% weitere Pakete hier

% Referenzen schön formatieren, Kommandos
% \cite  -> [x]
% \citet -> Name [x]
\usepackage[sort&compress,numbers]{natbib}
\setlength{\bibsep}{2pt plus 0.3ex}
\renewcommand*{\bibfont}{\small}
\makeatletter
\def\NAT@spacechar{~}% NEW
\makeatother

% Klickbare Links im Dokument
\usepackage{hyperref} % muss als vorletztes Paket eingebunden werden
% Evtl auskommentieren

% Querverweise mit \cref und \Cref
\usepackage[ngerman]{babel}
\usepackage[ngerman,noabbrev]{cleveref} % muss als letztes Paket eingebunden werden


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\textbf{EvoSuite}\\
Automatic Test Suite Generation for Java}
\author{Adrian Uffmann\\
Matrikelnummer: 12043921\\
\texttt{adrian.uffmann@campus.lmu.de}}
\date{09.02.2020}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{center}
Masterseminar Fuzz Testing
\end{center}

\begin{abstract}
EvoSuite ist ein Programm, welches mithilfe eines genetischen Algorithmus automatisiert JUnit-Testfälle aus Java-Bytecode generieren kann.
Auf der Internetseite des Projektes (\url{http://www.evosuite.org/publications/}) werden 54 Publikationen zu EvoSuite und dessen Vorgänger ${\mu}Test$ aufgelistet.
Diese Seminararbeit gibt einen Überblick über die Funktionsweise von EvoSuite.
\end{abstract}

\section{Einleitung}

Das Testen von Software ist ein wichtiger Teil der Softwareentwicklung, so schreiben \citet{myers2004art}:
\begin{quote}
it [is] a well-known rule of thumb that in a typical programming project approximately 50 percent of the elapsed time and more than 50 percent of the total cost [are] expended in testing the program or system being developed.
\end{quote}
Daher ist es kaum verwunderlich, dass es zahlreiche Werkzeuge gibt, die helfen sollen das Testen von Software zu automatisieren.
EvoSuite geht noch einen Schritt weiter: hier wird nicht versucht das Testen der Software zu automatisieren, sondern das Erstellen von automatisierten Tests selbst durch Automatisierung zu vereinfachen.
Der Fokus liegt dabei auf der Optimierung eines \textit{test last} Ansatzes, d. h. getestet wird erst, nachdem das eigentliche Programm fertig implementiert ist.
Bei diesem Ansatz würde sich ein Softwaretester zunächst Szenarien überlegen, mit denen er möglichst viele Pfade des Programms abdeckt und diese als Unittests ausformulieren.
Mithilfe von sogenannten Orakeln wird dabei ein bestimmtes Verhalten des Programms definiert.
Verhält sich das Programm anders als von den Orakeln vorgegeben, so schlägt der Test fehl und es wurde ein Bug gefunden.

EvoSuite versucht nun diesen Prozess zu vereinfachen, indem es Unittests generiert, die das Verhalten des Programms möglichst gut beschreiben.
Ein Softwaretester muss sich dann nicht mehr selbst Szenarien überlegen, sondern nur noch die generierten Testfälle auf unerwartetes Verhalten prüfen.
Dazu nutzt EvoSuite einen genetischen Algorithmus mit dem zufällige Test-fälle immer weiter verbessert werden, bis sie eine möglichst hohe Testabdeckung erreichen.
Die Testfälle werden dann minimiert um die Arbeit des Softwaretesters zu vereinfachen und es werden mit sogenanntem \textit{Mutation-Testing} möglichst repräsentative Orakel ausgewählt.

EvoSuite wurde seit 2010 immer weiter entwickelt und es sind verschiedene Algorithmen für das generieren von Testfällen implementiert, die über die Kommandozeile ein- und ausgeschaltet werden können.
Dazu haben die Autoren von EvoSuite auf der Internetseite (\url{http://www.evosuite.org/publications/}) 54 Artikel über die Konzepte in und die Evaluation von EvoSuite und dessen Vorgänger ${\mu}Test$ veröffentlicht.
Um den vorgegebenen Umfang einzuhalten, kann diese Seminararbeit nur Überblick über einen kleinen Teil von EvoSuite geben.

\section{Genetische Algorithmen}
\label{sec:gen_alg}

Genetische Algorithmen gehören zu den Evolutionären Algorithmen.
Die Idee dabei ist es, den Prozess der Evolution und natürlichen Auslese aus der Biologie zu simulieren, um Optimierungsprobleme zu lösen.
Dazu werden Lösungskandidaten für das Optimierungsproblem als Individuen betrachtet.
Die Menge der betrachteten Individuen nennt man auch Population oder Generation.
Ausgehend von einer Anfangspopulation werden zufällig mit \textit{crossover} und Mutation neue Individuen erzeugt und anhand einer Fitnessfunktion bewertet.
Anhand von der Bewertung wird eine Menge der Individuen ausgewählt um die neue Population zu bilden.
Die restlichen Individuen werden verworfen.

Dieser iterative Prozess wird so lange ausgeführt, bis ein Individuum gefunden wurde, welches das Optimierungsproblem optimal löst, bis eine vorgegebene Anzahl an Generationen entwickelt wurde, oder bis die verfügbare Zeit aufgebraucht ist.
In jedem Fall ist das Ergebnis des genetischen Algorithmus das beste Individuum.

Um ein konkretes Optimierungsproblem mit einem genetischen Algorithmus zu lösen, muss genau definiert werden: was ein Individuum ist, aus welchen Individuen die Anfangspopulation besteht, wie die \textit{crossover}- und Mutationsoperatoren neue Individuen erzeugen und wie die Fitnessfunktion aussieht.
Dies ist von Problem zu Problem unterschiedlich.

\section{Erzeugen von Testfällen}

\subsection{Betrachten von ganzen Testsuites auf einmal}

EvoSuite beginnt mit dem Generieren von Testfällen ohne Orakel.
Dafür werden verschiedene Algorithmen angeboten, in dieser Seminararbeit wird jedoch nur das Verbessern von ganzen Testsuites hinsichtlich der Testabdeckung mit einem genetischen Algorithmus nach \cite{TSE12_EvoSuite} beschrieben.

Die Verbesserung von ganzen Testsuites auf einmal ist dabei eine wichtige Neuerung, die vor EvoSuite, nach bestem Wissen der Autoren, nicht verwendet wurde.
Nach \cite{?} betrachteten ältere Werkzeuge nur einzelne Programmpfade auf einmal und versuchten einzelne Testfälle zu generieren, die die ausgewählten Pfade abdeckten.
Ein großes Problem bei diesem Ansatz ist jedoch, dass nicht jeder Programmpfad auch erreichbar ist.
Wenn versucht wird einen unerreichbaren Pfad zu erreichen, dann ist der dafür verwendete Aufwand verschwendet.
Ob ein bestimmter Pfad überhaupt erreichbar ist, ist allerdings ein unentscheidbares Problem, da man sonst das Halteproblem lösen könnte.
Bei diesem Ansatz ist es demnach sehr wichtig, mit welchen Programmpfaden begonnen wird.

Ein weiteres Problem ist Kollateralabdeckung.
Wenn zunächst Testfälle generiert werden, die einfache Pfade nahe der Oberfläche des Programms abdecken, kann es passieren, dass dieselben Pfade auch erreicht werden, wenn später Testfälle für tiefere Pfade des Programms generiert werden.
Dadurch werden die zuerst generierten Testfälle nutzlos, da sie keinen Beitrag mehr zur Testabdeckung beitragen und der Aufwand sie zu generieren war verschwendet.

EvoSuite vermeidet diese Probleme, indem die Testabdeckung der gesamten Testsuite auf einmal verbessert wird.
Statt einzelne Programmpfade auszuwählen, die erreicht werden sollen, wird bei EvoSuite gemessen, wie weit die gesamte Testsuite davon entfernt ist, alle Programmpfade abzudecken.

\subsection{Genetischer Algorithmus für das Generieren von Testsuites}

Wie in \cref{sec:gen_alg} erwähnt, muss für die Nutzung eines genetischen Algorithmus zunächst definiert werden, wie ein Individuum aussieht.
Da EvoSuite ganze

\section{Erzeugen von Orakeln mit Mutation-Testing}

Dieser Abschnitt stützt sich vor allem auf \cite{TSE12_Mutation}.

Mutation bedeutet hier etwas anderes, als bei genetischen Algorithmen.

\section{Search-Based Software Testing Competition}

\section{Praxistauglichkeit}

\section{Fazit}

\bibliography{references}
\bibliographystyle{plainnat}

\end{document}

%Originalpapiere siehe z.B.: \cite{TSE12_EvoSuite,10.1109/32.57624,emse14_mutation},
%Zitieren mit Autorennamen, z.B.: \citet{TSE12_EvoSuite}.
%Grundlagen in \cref{sec:background} und Code Beispiel in \cref{fig:abs}.
%
%Infos zu \LaTeX: \url{https://en.wikibooks.org/wiki/LaTeX}
%
%\begin{figure}
%\centering
%\begin{verbatim}
%int abs(int x) {
%    if(x >= 0) return x;
%    else return -x;
%}
%\end{verbatim}
%\caption{Betragsfunktion in C/Java}
%\label{fig:abs}
%\end{figure}
